const context = struct {
  srcs: lists::list,
  binary_name: strings::string,
};

const add_sources = fn(ctx: *context, path: strings::string) {
    const files = std::list_files(path);
    let index = 0;
    while index < files.len {
        const ptr = files.data;
        const str_ptr = @cast(*strings::string, ptr[index]);
        add_src(ctx, *str_ptr);
        index = index + 1;
    };
    return;
};

const add_src = fn(ctx: *context, path: strings::string) {
  lists::push(&ctx.srcs, std::promote(&path, @valuesize(path)));
  const ptr = ctx.srcs.data;
  const str = @cast(*strings::string, ptr[ctx.srcs.len - 1]);

  // cstd::printf("[builder-lib] adding source file '%s'\n", path.data);
  return;
};

const add_std = fn(ctx: *context) {
    const luna_std_home = cstd::getenv("LUNA_STD");
    if luna_std_home == @cast(*i8, 0) {
        cstd::puts("Missing LUNA_STD environment variable required to link with luna std lib.");
        std::assert(0);
        return;
    };

    const luna_std_home_str = strings::make_from(luna_std_home);
    strings::append::cstr(&luna_std_home_str, "/lib");

    add_sources(ctx, luna_std_home_str);
    return;
};

const compile_with_exec = fn(l: *lists::list) {
    const pid = cstd::fork();
    if pid == 0 {
        const args = @cast(**i8, cstd::malloc(l.len * @typesize(*i8) + 2));
        args[0] = "lunac";
        let index = 0;
        while index < l.len {
            const ptr = l.data;
            const str = @cast(*strings::string, ptr[index]);

            args[index+1] = str.data;

            index = index + 1;
        };
        args[index+1] = @cast(*i8, 0);

        const print_args = fn(args: **i8, argc: i32) {
            cstd::puts("about to print args:");
            cstd::printf("argc: %d\n", argc);

            let index = 0;
            cstd::printf("index: %d\n", index);
            while index < argc {
                cstd::printf("2. index: %d\n", index);
                cstd::printf("\t'%s'\n", args[index]);
                index = index + 1;
            };
            cstd::printf("Printed all %d args.", argc);
            return;
        };

        // cstd::printf("Printing args:\n");
        // print_args(args, l.len + 2);

        const fd = cstd::open("/dev/null", 1);
        if fd < 0 {
            cstd::perror("open");
            std::assert(0);
        };

        if cstd::dup2(fd, 1) < 0 {
            cstd::perror("dup2");
            cstd::close(fd);
            std::assert(0);
        };

        cstd::close(fd);


        const result = cstd::execvp("lunac", args);
        cstd::printf("result: %d\n", result);
        cstd::exit(1);
    } else if pid > 0 {
        const status: i32 = 0;
        cstd::waitpid(pid, &status, 0);
    } else {
        cstd::perror("failed to fork.");
        std::assert(0);
    };
    return;
};

const compile = fn(ctx: *context) {
    compile_with(&ctx.srcs, &ctx.binary_name);
    return;
};

const compile_with = fn(files: *lists::list, binary_name: *strings::string) {
    compile_with_exec(files);

    cstd::system("llc -filetype=asm out/compiled.ll");
    cstd::system("as out/compiled.s -o out/compiled.o");
    const section_one_linux = "clang -no-pie out/compiled.o -o";
    const section_one_mac = "clang out/compiled.o -o";
    const buf: [i8; 64] = [0];
    cstd::sprintf(buf, "%s %s", section_one_mac, binary_name.data);
    cstd::system(buf);

    // cstd::system("./out/compiled");
    return;
};
