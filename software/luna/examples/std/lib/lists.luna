const list = struct {
  data: **i8,
  len: i32,
  cap: i32,
  size: i32,
};

const make = fn(element_size: i32): list {
  return .list {
      data: cstd::malloc(element_size * 10)
      len: 0,
      cap: 10,
      size: element_size
  };
};

// TODO: may need to get some more stuff done before this.
// const prepend = fn(l: *list, data: *i8) {
//     if l.len == 0 {
//         const ptr = l.data;
//         ptr[0] = data;
//         l.len = 1;
//     } else if l.len < l.cap {
//         // 1. memcpy shift down
//         const ptr = l.data;
//         // cstd::memmove(ptr + @cast(i8, l.len + 1 ));
//         // 2. insert new
//         const ptr = l.data;
//         ptr[l.len] = data;
//         // 3. update len
//         l.len = l.len + 1;
//     };
// };

const grow = fn(l: *list, new_cap: i32) {
    l.cap = new_cap;
    l.data = @cast(**i8, cstd::realloc(l.data, new_cap * l.size));
};

const push = fn(l: *list, data: *i8) {
  if l.len == l.cap {
      grow(l, l.cap + 10);
  };

  l.data[l.len] = data;
  l.len = l.len + 1;
};

const each = fn(l: *list, f: fn(index: i32, value: *i8)) {
  let index = 0;

  while index < l.len {
      f(index, l.data[index]);
      index = index + 1;
  };
};

const print = fn(l: *list) {
  cstd::printf("list (%d/%d):\n", l.len, l.cap);
  each(l, fn(index:i32, value: *i8) {
      cstd::printf("\t%d: %d\n", index, *value);
  });
};
