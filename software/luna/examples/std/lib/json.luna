const Field = struct {
    name: strings::string,
    value: *Value,
    next: *Field
};

const Object = struct {
    fields: *Field,
};

const ValueType = mod {
    const UNKNOWN = 0;
    const STRING = 1;
    const NUMBER = 2;
    const BOOL = 3;
    const ARRAY = 4;
    const OBJECT = 5;
};

const Element = struct {
    value: *Value,
    next: *Element,
};

const Array = struct {
    elements: *Element,
    length: i32
};

const Value = struct {
    type: i32,
    string: strings::string,
    number: i64,
    bool: i1,
    array: *Array,
    object: *Object,
};

const make_string = fn(value: strings::string): Value {
    return .Value {
        type: ValueType::STRING,
        string: value,
        number: 0,
        bool: 0,
        array: @cast(*Array, 0),
        object: @cast(*Object, 0),
    };
};

const make_number = fn(number: i64): Value {
    return .Value {
        type: ValueType::NUMBER,
        string: strings::make(""),
        number: number,
        bool: 0,
        array: @cast(*Array, 0),
        object: @cast(*Object, 0),
    };
};

const make_bool = fn(bool: i1): Value {
    return .Value {
        type: ValueType::BOOL,
        string: strings::make(""),
        number: 0,
        bool: bool,
        array: @cast(*Array, 0),
        object: @cast(*Object, 0),
    };
};

const make_array = fn(array: *Array): Value {
    return .Value {
        type: ValueType::ARRAY,
        string: strings::make(""),
        number: 0,
        bool: 0,
        array: array,
        object: @cast(*Object, 0),
    };
};

const make_object = fn(object: *Object): Value {
    return .Value {
        type: ValueType::OBJECT,
        string: strings::make(""),
        number: 0,
        bool: 0,
        array: @cast(*Array, 0),
        object: object,
    };
};

const object = mod {
    const get = fn(obj: *Object, name: strings::string): *Value {
        let field = obj.fields;
        while field != @cast(*Field, 0) {
            if strings::equal(name, field.name) {
                return field.value;
            };
            field = field.next;
        };

        return @cast(*Value, 0);
    };
};

const parser = mod {
    const Context = struct {
        source: strings::string,
        index: i32,
    };

    const make = fn(str: strings::string): Context {
        return .Context {
            source: str,
            index: 0,
        };
    };

    const peek = fn(ctx: *Context): i8 {
        const peek_inner = fn(context: *Context): i8 {
            if context.index >= context.source.len {
                return 0;
            };
            const ptr = context.source.data;
            return ptr[context.index];
        };

        while cstd::isspace(peek_inner(context)) {
            context.index = context.index + 1;
        };

        return peek_inner(context);
    };

    const expect = fn(ctx: *Context, expected: i8) {
        const actual = peek(ctx);
        std::assert(actual == expected);
        context.index = context.index + 1;
        return;
    };

    const take = fn(ctx: *Context): i8 {
        const value = peek(ctx);
        ctx.index = ctx.index + 1;
        return value;
    };

    const parse_string = fn(ctx: *Context): strings::string {
        expect(ctx, "\"");
        const inner = strings::make_from("");
        let val = peek(ctx);
        while val != "\"" {
            val = take(ctx);
            strings::append::cstr(&inner, &val);
        };
        expect(ctx, "\"");
        return inner;
    };

    const parse_value = fn(ctx: *Context): *Value {
        return @cast(*Value, 0);
    };

    const parse = fn(source: strings::string): *Value {
        const ctx = parser::make(source);
        return parse_value(ctx);
    };
};

