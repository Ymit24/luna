const assert = fn(condition: i1) {
    if condition != 1 {
        cstd::printf("Assertion failed.");
        cstd::abort();
    };
    return;
};

const promote = fn(obj: *i8, size: u16): *i8 {
    const ptr = cstd::malloc(size);
    cstd::memcpy(ptr, obj, size);
    return ptr;
};



const list_files = fn(path: *i8): lists::list {

    // cstd::puts("Opening dir..");
    const dir = cstd::opendir(path);
    if dir == 0 {
        cstd::perror("opendir");
        assert(0);
    };
    // cstd::puts("Opened dir.");

    let ent = @cast(*cstd::dirent, 0);

    let list_of_files = lists::make(@typesize(strings::string));
    const first_file_str = strings::make("../cstd.luna");
    lists::push(&list_of_files, promote(&first_file_str, @valuesize(first_file_str)));

    // cstd::printf("Size of string: %d - %d\n", list_of_files.size, @typesize(strings::string));

    // const str = strings::make("foo");

    // const raw = "hello";
    // const str2 = strings::make_from(raw);

    // cstd::printf("Len of '%s' is %d\n", str.data, str.len);
    // cstd::printf("Len of '%s' is %d\n", str2.data, str2.len);

    ent = cstd::readdir(dir);
    while ent != 0 {
        // cstd::printf("\tread something.\n");
        // cstd::printf("\t\t%s\n", &ent.d_name);
        // cstd::printf("\t\t\ttype: %d\n", ent.d_type);
        if ent.d_type == 8 {
            // cstd::puts("\t\t\tFILE");

            const file_str = strings::make_from(&ent.d_name);

            const file_str_ptr = @cast(*strings::string, promote(&file_str, @valuesize(file_str)));

            // cstd::printf("filestrptr:%s: %d\n", file_str_ptr.data, file_str_ptr.len);

            // cstd::printf("str len of file str is '%s' is %d\n", file_str.data, file_str.len);
            lists::push(&list_of_files, @cast(*i8, file_str_ptr));
        };
        if ent.d_type == 4 {
            // cstd::puts("\t\t\tFOLDER");
        };
        ent = cstd::readdir(dir);
    };

    // cstd::puts("Closing dir..");
    cstd::closedir(dir);
    // cstd::puts("Closed dir.");

    cstd::puts("File names:");

    lists::each(&list_of_files, fn(index: i32, data: *i8){
        const str = @cast(*strings::string, data);
        cstd::printf("\tFile: %s\n", str.data);
        return;
    });

    return list_of_files;
};


const compile_with_exec = fn(l: *lists::list) {
    const pid = cstd::fork();
    if pid == 0 {
        const args = @cast(**i8, cstd::malloc(l.len * @typesize(*i8) + 2));
        args[0] = "lunac";
        let index = 0;
        while index < l.len {
            const ptr = l.data;
            const str = @cast(*strings::string, ptr[index]);

            args[index+1] = str.data;

            index = index + 1;
        };
        args[index+1] = @cast(*i8, 0);

        const fd = cstd::open("/dev/null", 1);
        if fd < 0 {
            cstd::perror("open");
            assert(0);
        };

        if cstd::dup2(fd, 1) < 0 {
            cstd::perror("dup2");
            cstd::close(fd);
            assert(0);
        };

        cstd::close(fd);


        const result = cstd::execvp("lunac", args);
        cstd::printf("result: %d\n", result);
        cstd::exit(1);
    } else if pid > 0 {
        const status: i32 = 0;
        cstd::waitpid(pid, &status, 0);
    } else {
        cstd::perror("failed to fork.");
        assert(0);
    };
    return;
};

const compile = fn() {
    // const status = cstd::system(
    //     "lunac ../cstd.luna lists.luna strings.luna builder_main.luna"
    // );

    const files = list_files(".");
    compile_with_exec(&files);

    // cstd::printf("Result: %d\n", status);
    //
    cstd::system("llc out/compiled.ll");
    cstd::system("as out/compiled.s -o out/compiled.o");
    cstd::system("clang out/compiled.o -o out/compiler");

    cstd::puts("Fully built.");

    // cstd::system("./out/compiled");
    return;
};

const main = fn(argc: i8, argv: **i8): i32 {
    if argc < 2 {
        cstd::puts("usage: luna <command>");

        return 1;
    };

    if cstd::strncmp("build", argv[1], 5) == 0 {
        cstd::puts("found build");
        compile();
    } else if cstd::strncmp("run", argv[1], 3) == 0 {
        cstd::puts("found run");
    } else {
        cstd::printf("unknown command '%s'.\n", argv[1]);
        return 1;
    };

    return 0;
};

// cstd::printf("Builder got called with %d arguments.\n", argc);
//
// let index = 0;
// while index < argc {
//     cstd::printf("\t'%s'\n", argv[index]);
//     index = index + 1;
// };

// cstd::puts("about to list files..");
// const files = list_files(".");


// cstd::puts("running compile with exec:");
// compile_with_exec(&files);
// cstd::puts("ran.");

//
// cstd::puts("Listing files returned.");
// cstd::printf("Got %d files.\n", files.len);
// lists::each(&files, fn(index: i32, data: *i8){
//     const str = @cast(*strings::string, data);
//     cstd::printf("\tFile: '%s'\n", str.data);
//     return;
// });
//
// const mylist: lists::list = lists::make(4);
//
// lists::print(&mylist);
//
// const a = 8;
// const b = 3;
// const c = 9;
//
// lists::push(&mylist, &a);
// lists::push(&mylist, &b);
// lists::push(&mylist, &c);
//
// lists::print(&mylist);
// lists::each(&mylist, fn(idx:i32, v: *i8) {
//     cstd::printf("EACH: %d -> %d\n", idx+3, *v);
//     return;
// });

// lists::each(&files, fn(index: i32, data: *i8){
//     const str = @cast(*strings::string, data);
//     cstd::free(str.data);
//     return;
// });
