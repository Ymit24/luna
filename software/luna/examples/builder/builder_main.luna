const assert = fn(condition: i1) {
    if condition != 1 {
        cstd::printf("Assertion failed.");
        cstd::abort();
    };
    return;
};

const list_files = fn(path: *i8): lists::list {
    cstd::printf("Files in %s:\n", path);

    cstd::puts("Opening dir..");
    const dir = cstd::opendir(path);
    if dir == 0 {
        cstd::perror("opendir");
        assert(0);
    };
    cstd::puts("Opened dir.");

    let ent = @cast(*cstd::dirent, 0);

    let list_of_files = lists::make(@typesize(strings::string));

    cstd::printf("Size of string: %d - %d\n", list_of_files.size, @typesize(strings::string));

    const str = strings::make("foo");

    const raw = "hello";
    const str2 = strings::make_from(raw);

    cstd::printf("Len of '%s' is %d\n", str.data, str.len);
    cstd::printf("Len of '%s' is %d\n", str2.data, str2.len);

    ent = cstd::readdir(dir);
    while ent != 0 {
        cstd::printf("\tread something.\n");
        cstd::printf("\t\t%s\n", &ent.d_name);
        cstd::printf("\t\t\ttype: %d\n", ent.d_type);
        if ent.d_type == 8 {
            cstd::puts("\t\t\tFILE");

            const promote = fn(obj: *i8, size: u16): *i8 {
                const ptr = cstd::malloc(size);
                cstd::memcpy(ptr, obj, size);
                return ptr;
            };

            const file_str = strings::make_from(&ent.d_name);

            const file_str_ptr = @cast(*strings::string, promote(&file_str, @valuesize(file_str)));

            cstd::printf("filestrptr:%s: %d\n", file_str_ptr.data, file_str_ptr.len);

            cstd::printf("str len of file str is '%s' is %d\n", file_str.data, file_str.len);
            lists::push(&list_of_files, @cast(*i8, file_str_ptr));
        };
        if ent.d_type == 4 {
            cstd::puts("\t\t\tFOLDER");
        };
        ent = cstd::readdir(dir);
    };

    cstd::puts("Closing dir..");
    cstd::closedir(dir);
    cstd::puts("Closed dir.");

    cstd::puts("File names:");

    lists::each(&list_of_files, fn(index: i32, data: *i8){
        const str = @cast(*strings::string, data);
        cstd::printf("\tFile: %s\n", str.data);
        return;
    });

    return list_of_files;
};

const compile = fn() {
    const status = cstd::system("lunac ../cstd.luna lists.luna strings.luna builder_main.luna");

    cstd::printf("Result: %d\n", status);

    cstd::system("llc out/compiled.ll");
    cstd::system("as out/compiled.s -o out/compiled.o");
    cstd::system("clang out/compiled.o -o out/compiler");

    cstd::puts("Fully built.");

    // cstd::system("./out/compiled");
    return;
};

const main = fn(argc: i8, argv: **i8): i32 {
    cstd::puts("Hello from builder.");
    cstd::printf("Builder got called with %d arguments.\n", argc);

    let index = 0;
    while index < argc {
        cstd::printf("\t'%s'\n", argv[index]);
        index = index + 1;
    };

    compile();

    cstd::puts("about to list files..");
    const files = list_files(".");

    cstd::puts("Listing files returned.");
    cstd::printf("Got %d files.\n", files.len);
    lists::each(&files, fn(index: i32, data: *i8){
        const str = @cast(*strings::string, data);
        cstd::printf("\tFile: '%s'\n", str.data);
        return;
    });

    const mylist: lists::list = lists::make(4);

    lists::print(&mylist);

    const a = 8;
    const b = 3;
    const c = 9;

    lists::push(&mylist, &a);
    lists::push(&mylist, &b);
    lists::push(&mylist, &c);

    lists::print(&mylist);
    lists::each(&mylist, fn(idx:i32, v: *i8) {
        cstd::printf("EACH: %d -> %d\n", idx+3, *v);
        return;
    });

    lists::each(&files, fn(index: i32, data: *i8){
        const str = @cast(*strings::string, data);
        cstd::free(str.data);
        return;
    });
    return 0;
};
