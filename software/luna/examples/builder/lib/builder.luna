const context = struct {
  srcs: lists::list,
  binary_name: strings::string,
};

const add_src = fn(context: *context, path: strings::string) {
  cstd::printf("Adding src: %s\n", path.data);
  lists::push(&context.srcs, std::promote(&path, @valuesize(path)));
  const ptr = context.srcs.data;
  const str = @cast(*strings::string, ptr[context.srcs.len - 1]);
  cstd::printf("str: %s\n", str.data);
  return;
};

const compile_with_exec = fn(l: *lists::list) {
    const pid = cstd::fork();
    if pid == 0 {
        const args = @cast(**i8, cstd::malloc(l.len * @typesize(*i8) + 2));
        args[0] = "lunac";
        let index = 0;
        while index < l.len {
            const ptr = l.data;
            const str = @cast(*strings::string, ptr[index]);

            args[index+1] = str.data;

            index = index + 1;
        };
        args[index+1] = @cast(*i8, 0);

        const fd = cstd::open("/dev/null", 1);
        if fd < 0 {
            cstd::perror("open");
            std::assert(0);
        };

        if cstd::dup2(fd, 1) < 0 {
            cstd::perror("dup2");
            cstd::close(fd);
            std::assert(0);
        };

        cstd::close(fd);


        const result = cstd::execvp("lunac", args);
        cstd::printf("result: %d\n", result);
        cstd::exit(1);
    } else if pid > 0 {
        const status: i32 = 0;
        cstd::waitpid(pid, &status, 0);
    } else {
        cstd::perror("failed to fork.");
        std::assert(0);
    };
    return;
};

const compile = fn(ctx: *context) {
    // const files = std::list_files("src/");
    compile_with_exec(&ctx.srcs);

    cstd::system("llc out/compiled.ll");
    cstd::system("as out/compiled.s -o out/compiled.o");
    const section_one = "clang out/compiled.o -o";
    const buf: [i8; 64] = [0];
    cstd::sprintf(buf, "%s %s", section_one, ctx.binary_name.data);
    cstd::printf("buf: '%s'\n", buf);
    cstd::system(buf);

    cstd::puts("Fully built.");

    // cstd::system("./out/compiled");
    return;
};

const main = fn() {
    const ctx = .context {
        srcs: lists::make(@typesize(strings::string)),
        binary_name: strings::make("out/default"),
    };

    build::build(&ctx);

    lists::each(&ctx.srcs, fn(index: i32, value: *i8) {
        const str = @cast(*strings::string, value);
        cstd::printf("src: %s\n", str.data);
        return;
    });

    return;
};
