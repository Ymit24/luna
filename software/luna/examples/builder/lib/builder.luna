const context = struct {
  srcs: lists::list,
  binary_name: strings::string,
};

const add_src = fn(context: *context, path: strings::string) {
  // cstd::printf("Adding src: %s\n", path.data);
  lists::push(&context.srcs, std::promote(&path, @valuesize(path)));
  const ptr = context.srcs.data;
  const str = @cast(*strings::string, ptr[context.srcs.len - 1]);
  // cstd::printf("str: %s\n", str.data);
  return;
};

const compile_with_exec = fn(l: *lists::list) {
    const pid = cstd::fork();
    if pid == 0 {
        const args = @cast(**i8, cstd::malloc(l.len * @typesize(*i8) + 2));
        args[0] = "lunac";
        let index = 0;
        while index < l.len {
            const ptr = l.data;
            const str = @cast(*strings::string, ptr[index]);

            args[index+1] = str.data;

            index = index + 1;
        };
        args[index+1] = @cast(*i8, 0);

        const print_args = fn(args: **i8, argc: i32) {
            cstd::puts("about to print args:");
            cstd::printf("argc: %d\n", argc);

            let index = 0;
            cstd::printf("index: %d\n", index);
            while index < argc {
                cstd::printf("2. index: %d\n", index);
                cstd::printf("\t'%s'\n", args[index]);
                index = index + 1;
            };
            cstd::printf("Printed all %d args.", argc);
            return;
        };

        cstd::printf("Printing args:\n");
        print_args(args, l.len + 2);

        const fd = cstd::open("/dev/null", 1);
        if fd < 0 {
            cstd::perror("open");
            std::assert(0);
        };

        if cstd::dup2(fd, 1) < 0 {
            cstd::perror("dup2");
            cstd::close(fd);
            std::assert(0);
        };

        cstd::close(fd);


        const result = cstd::execvp("lunac", args);
        cstd::printf("result: %d\n", result);
        cstd::exit(1);
    } else if pid > 0 {
        const status: i32 = 0;
        cstd::waitpid(pid, &status, 0);
    } else {
        cstd::perror("failed to fork.");
        std::assert(0);
    };
    return;
};

const compile = fn(ctx: *context) {
    compile_with(&ctx.srcs, &ctx.binary_name);
    return;
};

const compile_with = fn(files: *lists::list, binary_name: *strings::string) {
    compile_with_exec(files);

    cstd::system("llc -filetype=asm out/compiled.ll");
    cstd::system("as out/compiled.s -o out/compiled.o");
    const section_one = "clang -no-pie out/compiled.o -o";
    const buf: [i8; 64] = [0];
    cstd::sprintf(buf, "%s %s", section_one, binary_name.data);
    cstd::printf("buf: '%s'\n", buf);
    cstd::system(buf);

    cstd::puts("Fully built.");

    // cstd::system("./out/compiled");
    return;
};
