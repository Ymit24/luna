const strings = use "strings";
const lexer = use "./lexer.luna";
const ast = use "./ast.luna";

const typechecker = mod {
    const TypeKind = enum {
        PRIMITIVE,
        POINTER,
        STRUCT,
        ENUM,
        UNION,
        FUNCTION,
        GENERIC,
        MODULE,
        VOID,
        ERROR,
    };
    
    const Type = struct {
        kind: TypeKind,
        name: strings::string,
        size: u32,
        pointer_to: *Type,
        struct_fields: *StructField,
        field_count: u32,
        function_params: *Type,
        param_count: u32,
        return_type: *Type,
    };
    
    const StructField = struct {
        name: strings::string,
        field_type: *Type,
        offset: u32,
    };
    
    const Symbol = struct {
        name: strings::string,
        symbol_type: *Type,
        is_mutable: i1,
        scope_level: u32,
    };
    
    const SymbolTable = struct {
        symbols: *Symbol,
        symbol_count: u32,
        parent: *SymbolTable,
        scope_level: u32,
    };
    
    const TypeChecker = struct {
        current_scope: *SymbolTable,
        global_scope: *SymbolTable,
        types: *Type,
        type_count: u32,
        errors: **strings::string,
        error_count: u32,
    };
    
    // Built-in types
    let i32_type: Type;
    let u32_type: Type;
    let i1_type: Type;
    let u16_type: Type;
    let void_type: Type;
    let error_type: Type;
    
    const init_builtin_types = fn() {
        i32_type = Type {
            kind: TypeKind::PRIMITIVE,
            name: strings::from("i32"),
            size: 4,
            pointer_to: nil,
            struct_fields: nil,
            field_count: 0,
            function_params: nil,
            param_count: 0,
            return_type: nil,
        };
        
        u32_type = Type {
            kind: TypeKind::PRIMITIVE,
            name: strings::from("u32"),
            size: 4,
            pointer_to: nil,
            struct_fields: nil,
            field_count: 0,
            function_params: nil,
            param_count: 0,
            return_type: nil,
        };
        
        i1_type = Type {
            kind: TypeKind::PRIMITIVE,
            name: strings::from("i1"),
            size: 1,
            pointer_to: nil,
            struct_fields: nil,
            field_count: 0,
            function_params: nil,
            param_count: 0,
            return_type: nil,
        };
        
        u16_type = Type {
            kind: TypeKind::PRIMITIVE,
            name: strings::from("u16"),
            size: 2,
            pointer_to: nil,
            struct_fields: nil,
            field_count: 0,
            function_params: nil,
            param_count: 0,
            return_type: nil,
        };
        
        void_type = Type {
            kind: TypeKind::VOID,
            name: strings::from("void"),
            size: 0,
            pointer_to: nil,
            struct_fields: nil,
            field_count: 0,
            function_params: nil,
            param_count: 0,
            return_type: nil,
        };
        
        error_type = Type {
            kind: TypeKind::ERROR,
            name: strings::from("error"),
            size: 0,
            pointer_to: nil,
            struct_fields: nil,
            field_count: 0,
            function_params: nil,
            param_count: 0,
            return_type: nil,
        };
    };
    
    const new = fn(): TypeChecker {
        init_builtin_types();
        
        let global_scope = SymbolTable {
            symbols: nil,
            symbol_count: 0,
            parent: nil,
            scope_level: 0,
        };
        
        let tc = TypeChecker {
            current_scope: &global_scope,
            global_scope: &global_scope,
            types: nil,
            type_count: 0,
            errors: nil,
            error_count: 0,
        };
        
        return tc;
    };
    
    const enter_scope = fn(tc: *TypeChecker) {
        let new_scope = SymbolTable {
            symbols: nil,
            symbol_count: 0,
            parent: tc.current_scope,
            scope_level: tc.current_scope.scope_level + 1,
        };
        tc.current_scope = &new_scope;
    };
    
    const exit_scope = fn(tc: *TypeChecker) {
        if tc.current_scope.parent != nil {
            tc.current_scope = tc.current_scope.parent;
        }
    };
    
    const define_symbol = fn(tc: *TypeChecker, name: strings::string, symbol_type: *Type, is_mutable: i1): i1 {
        // Check if symbol already exists in current scope
        let i: u32 = 0;
        while i < tc.current_scope.symbol_count {
            if strings::equals(tc.current_scope.symbols[i].name, name) {
                return 0; // Symbol already exists
            }
            i += 1;
        }
        
        // TODO: Add symbol to current scope
        // This would require dynamic array allocation
        
        return 1;
    };
    
    const lookup_symbol = fn(tc: *TypeChecker, name: strings::string): *Symbol {
        let scope = tc.current_scope;
        while scope != nil {
            let i: u32 = 0;
            while i < scope.symbol_count {
                if strings::equals(scope.symbols[i].name, name) {
                    return &scope.symbols[i];
                }
                i += 1;
            }
            scope = scope.parent;
        }
        return nil;
    };
    
    const get_builtin_type = fn(name: strings::string): *Type {
        if strings::equals(name, "i32") { return &i32_type; }
        if strings::equals(name, "u32") { return &u32_type; }
        if strings::equals(name, "i1") { return &i1_type; }
        if strings::equals(name, "u16") { return &u16_type; }
        if strings::equals(name, "void") { return &void_type; }
        return nil;
    };
    
    const types_equal = fn(a: *Type, b: *Type): i1 {
        if a == nil or b == nil { return 0; }
        if a.kind != b.kind { return 0; }
        
        if a.kind == TypeKind::PRIMITIVE or a.kind == TypeKind::VOID {
            return strings::equals(a.name, b.name);
        } else if a.kind == TypeKind::POINTER {
            return types_equal(a.pointer_to, b.pointer_to);
        } else if a.kind == TypeKind::FUNCTION {
            if a.param_count != b.param_count { return 0; }
            if !types_equal(a.return_type, b.return_type) { return 0; }
            
            let i: u32 = 0;
            while i < a.param_count {
                if !types_equal(&a.function_params[i], &b.function_params[i]) {
                    return 0;
                }
                i += 1;
            }
            return 1;
        }
        
        return strings::equals(a.name, b.name);
    };
    
    const check_program = fn(tc: *TypeChecker, program: *ast::ModuleStatement): i1 {
        let i: u32 = 0;
        while i < program.statement_count {
            if !check_statement(tc, program.statements[i]) {
                return 0;
            }
            i += 1;
        }
        return 1;
    };
    
    const check_statement = fn(tc: *TypeChecker, stmt: *ast::Statement): i1 {
        if stmt.node.type == ast::NodeType::LET_STATEMENT {
            return check_let_statement(tc, stmt);
        } else if stmt.node.type == ast::NodeType::CONST_STATEMENT {
            return check_const_statement(tc, stmt);
        } else if stmt.node.type == ast::NodeType::RETURN_STATEMENT {
            return check_return_statement(tc, stmt);
        } else if stmt.node.type == ast::NodeType::EXPRESSION_STATEMENT {
            return check_expression_statement(tc, stmt);
        } else if stmt.node.type == ast::NodeType::BLOCK_STATEMENT {
            return check_block_statement(tc, stmt);
        }
        return 0;
    };
    
    const check_let_statement = fn(tc: *TypeChecker, stmt: *ast::Statement): i1 {
        // TODO: Cast stmt to LetStatement and check types
        return 1;
    };
    
    const check_const_statement = fn(tc: *TypeChecker, stmt: *ast::Statement): i1 {
        // TODO: Cast stmt to ConstStatement and check types
        return 1;
    };
    
    const check_return_statement = fn(tc: *TypeChecker, stmt: *ast::Statement): i1 {
        // TODO: Cast stmt to ReturnStatement and check return type
        return 1;
    };
    
    const check_expression_statement = fn(tc: *TypeChecker, stmt: *ast::Statement): i1 {
        // TODO: Cast stmt to ExpressionStatement and check expression
        return 1;
    };
    
    const check_block_statement = fn(tc: *TypeChecker, stmt: *ast::Statement): i1 {
        enter_scope(tc);
        // TODO: Cast stmt to BlockStatement and check all statements
        let result = 1;
        exit_scope(tc);
        return result;
    };
    
    const check_expression = fn(tc: *TypeChecker, expr: *ast::Expression): *Type {
        if expr.node.type == ast::NodeType::IDENTIFIER {
            return check_identifier(tc, expr);
        } else if expr.node.type == ast::NodeType::INTEGER_LITERAL {
            return check_integer_literal(tc, expr);
        } else if expr.node.type == ast::NodeType::STRING_LITERAL {
            return check_string_literal(tc, expr);
        } else if expr.node.type == ast::NodeType::BOOLEAN_LITERAL {
            return check_boolean_literal(tc, expr);
        } else if expr.node.type == ast::NodeType::NIL_LITERAL {
            return check_nil_literal(tc, expr);
        } else if expr.node.type == ast::NodeType::PREFIX_EXPRESSION {
            return check_prefix_expression(tc, expr);
        } else if expr.node.type == ast::NodeType::INFIX_EXPRESSION {
            return check_infix_expression(tc, expr);
        } else if expr.node.type == ast::NodeType::IF_EXPRESSION {
            return check_if_expression(tc, expr);
        } else if expr.node.type == ast::NodeType::FUNCTION_LITERAL {
            return check_function_literal(tc, expr);
        } else if expr.node.type == ast::NodeType::CALL_EXPRESSION {
            return check_call_expression(tc, expr);
        }
        return &error_type;
    };
    
    const check_identifier = fn(tc: *TypeChecker, expr: *ast::Expression): *Type {
        // TODO: Cast expr to Identifier and lookup symbol
        return &i32_type;
    };
    
    const check_integer_literal = fn(tc: *TypeChecker, expr: *ast::Expression): *Type {
        return &i32_type;
    };
    
    const check_string_literal = fn(tc: *TypeChecker, expr: *ast::Expression): *Type {
        // TODO: Return string type (not implemented yet)
        return &error_type;
    };
    
    const check_boolean_literal = fn(tc: *TypeChecker, expr: *ast::Expression): *Type {
        return &i1_type;
    };
    
    const check_nil_literal = fn(tc: *TypeChecker, expr: *ast::Expression): *Type {
        // TODO: Return nil type (pointer to void?)
        return &error_type;
    };
    
    const check_prefix_expression = fn(tc: *TypeChecker, expr: *ast::Expression): *Type {
        // TODO: Cast expr to PrefixExpression and check operator compatibility
        return &error_type;
    };
    
    const check_infix_expression = fn(tc: *TypeChecker, expr: *ast::Expression): *Type {
        // TODO: Cast expr to InfixExpression and check operator compatibility
        return &error_type;
    };
    
    const check_if_expression = fn(tc: *TypeChecker, expr: *ast::Expression): *Type {
        // TODO: Cast expr to IfExpression and check condition is boolean
        return &error_type;
    };
    
    const check_function_literal = fn(tc: *TypeChecker, expr: *ast::Expression): *Type {
        // TODO: Cast expr to FunctionLiteral and create function type
        return &error_type;
    };
    
    const check_call_expression = fn(tc: *TypeChecker, expr: *ast::Expression): *Type {
        // TODO: Cast expr to CallExpression and check function signature
        return &error_type;
    };
};