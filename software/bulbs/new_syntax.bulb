# setup core registers
$__luna_prelude:
  # reset stack pointer
  push const 0x1000
  push const 0x1000
  pop %sp
  pop %bsp
  jmp $_start # or main or whatever the applications entry point is.

$__static_initializers:
  push %sp
  pop %x

  push const %static
  pop %sp
  push 100


  # NOTE: These are wrong ascii codes
  push const 0x50 # 'f'
  push const 0x58 # 'o'
  push const 0x58 # 'o'
  push const 0x0  # NULL

  push const 0x58 # 'o'
  push const 0x0  # NULL

  push %x
  pop %sp

$example_0:
  push const 5
  pop local 0

$example_1:
  push const 5
  pop local 0
  push local 0
  pop local 1

$example_2:
  push const 5
  pop local 0
  push local 0
  push const 0xFF
  add
  pop local 1

$example_3:
  push const 1
  pop local 0
  push const 0
  pop local 1
  push local 0
  push const 1
  sub
  jnq $__if_after
  # This block will handle 'goto $__if_after if (foo == 1)'
  # This is the impl of the jnq line above
  asm {
    @0 # goto %sp
    D = M # read current stack addr
    A = D-1 # goto last used addr (result of the sub)
    D = M # hold onto the value on stack which we care about
    A = $__if_after # Set addr to the place to jump to (known at compile time)
    _ = D; JNQ # if data value was zero, jump to $__if_after, otherwise noop
  }
  push const 1
  pop local 1
  $__if_after:
    noop

$example_4:
  $__while_conditional:
    push args 0
    jgt $__while_body
    jmp $__while_after
  $__while_body:
    push args 0
    push const 1
    sub
    jmp $__while_conditional
  $__while_after:

$example_5
  push const 100
  pop local 0

  push const 0
  pop local 1

  push %bsp
  push const 0
  add
  pop local 3

  push %bsp
  push const 1
  add
  pop local 4

  push local 3
  read # read instruction which translates into the below machine code
  asm {
    @0
    A = M - 1 # goto head of used stack
    A = M # goto addr
    D = M # read

    @0
    A = M # goto next free stack slot
    M = D # write the value

    @0
    M = M + 1 # increment stack pointer
  }

  push local 4
  write # opposite of read
  asm {
    @0
    A = M - 1 # goto last used stack slot
    A = M - 1 # go back one more stack slot
    D = M # read the value to write
    
    A = M - 1 # goto value holding addr to write
    A = M # goto that location
    M = D # write into the stored location

    @0
    M = M - 1 # decrement stack pointer
    M = M - 1 # decrement again to use both stack spots
  }

$memcp2:
  push args 0
  pop local 0 # s
  push args 1
  pop local 1 # d
  push const 0
  pop local 2 # i
  $for_cond:
    push local 2
    push args 2 # len 
    sub
    jgt $for_after
  $for_body:
    push local 0
    push local 2
    add
    read
    push local 1
    push local 2
    add
    write
  $for_inc:
    push local 2
    push local 1
    add
    pop local 2
    jmp $for_cond
  $for_after:
    ret

$ex
  push const 1
  pop local 0
  push const 2
  pop local 1
  push const 0
  pop local 2
  push const 0
  pop local 3

  # &x
  push %bsp
  push const 0
  add

  # &y
  push %bsp
  push const 2
  add
  
  # sizeof(struct two)
  push const 2
  call $memcpy2

  push local 3
  push const 1
  sub
  jeq $if_a_eq_one
  push const 0
  pop local 5 # eq
  jmp $after_if

  $if_a_eq_one:
    push const 1
    pop local 5 # eq
  $after_if:
    push local 3
    push const 1
    sub
